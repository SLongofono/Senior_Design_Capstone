Design Decisions and Alternate Designs Considered

There are innumerable ways we could have designed our computer---ultimately, we adopted the familiar architecture approach presented in our computer architecture coursework.  The Von Neumann architecture presented by Hennessey and Patterson is widely employed in RISC-V implementations, and its modular nature makes it easy to extend and improve individual pieces as need be.

Processor Core
The core was designed to follow the modular, Von Neumann architecture presented in Computer Architecture: A Quantitative Approach by David Patterson and John Hennessey.  A control unit handles the bulk of the operating logic, sending signals to control the inputs and outputs among internal components and to the external modules like the MMU and the peripherals.  Within the core, each logical operation is delegated to its own module; a decoder processes binary instructions, an ALU handles arithmetic instructions, a register file stores and serves data from a bank of registers.  The advantages of this approach are that each module can be tested in isolation, and each module improved upon or otherwise modified in isolation.  The tradeoff is the complexity of implementing an interface among the modules and keeping the modules in lockstep with the core clock.

Initially, we also considered a monolithic, state-machine style design.  The latter would have made atomic instructions, interrupts, and general flow of information relatively simple.  Each possible behavior could be captured in a non-deterministic finite automaton, and reduced to the minimal equivalent deterministic automaton.  Such a design would eliminate timing issues altogether, and by nature eliminate unexpected or undefined behavior at clock boundaries.  However, the rigid design means that even small changes could require the state machine be redesigned and optimized.  We decided against his approach because it would limit the extensibility of our design and complicate the addition of pipelining in the future.

System Design
Initially, we had planned to implement the 32-bit core with extensions for multiplication, 64-bit instructions, floating-point operations, privileged instructions, and atomic operations.  These "standard" extensions are compatible with existing implementations that will run Linux.  As the semester progressed, it became clear that this was too ambitious.  We did not have enough time to complete and test all of the above and still have a working product to demonstrate.  Instead, we decided to implement incremental versions of the core, each adding in some core functionality and stubbing out or omitting the rest.  The first version implemented only arithmetic instructions, the second control and privileged instructions, the third load and jump instructions, and the final version atomic instructions.  Since it was possible to implement the operating system without floating point operations, we opted to omit it completely.

System Bus
We considered implementing multiple paging schemes in the MMU as that is what was done in the simulator, and it would not have been too difficult to do. When we discovered the only mode used by the Linux Kernel (sv39), we decided to only implement that. We wanted to implement a VGA and keyboard driver so that the computer could interact with the world. We eventually settled on just using UART as the input and output to the console. This allowed us to only design a single driver and still allows the system to interact through a serial connection with another computer. We also considered having a USB drive being the hard disc for our system. We decided against this as we did not have enough USB slots, and we would have needed to add additional drivers to the system. Instead the file system is read only and is stored on the ROM chip.

Operating System and ABI
Originally we considered a full Linux distribution for embedded projects. This was abandoned for a bare bones model for the added complexity and time it would have taken to run the programs and compile. We wanted to created system tests to ensure the proper operation of the different instructions under corner case conditions. This was abandoned for time reasons, and because we felt as though the debugger unit would be able to help us trouble shoot any problem instructions. 
