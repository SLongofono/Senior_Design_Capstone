\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[letterpaper, margin=1in]{geometry}
\usepackage[backend=biber,sorting=ynt]{biblatex}

\addbibresource{mybib.bib}

\title{RISC-V Computer Design}
\author{Cesar Avalos, Jacob Fustos, Stephen Longofono}
\date{December 2017}

\begin{document}

\maketitle

\section{Introduction  \& Overview}
This document details the design and implementation of a RISC-V core running Linux on the Nexys 4 FPGA target.  The RISC-V ISA is an open-source standard for research and development of computer architectures maintained by the RISC-V foundation.  In general, the ISA follows the philosophy of previous RISC implementations, favoring simplicity and regularity over specialization.  RISC-V offers constructs to support all major macro and micro-architectures, and as such is a worthwhile study to complete our undergraduate education.

RISC-V is modularized into a base integer set of instructions and operations; these fundamental instructions make up the minimum viable product for any RISC-V implementation\cite{RISCV_RDR}.  In order to implement the kernel, we will need to include a collection of extensions to the base set, dubbed "RV64G".  The RV64G extension composes the minimum instruction set for use in a standard Linux system.  It includes the base set of integer arithmetic instructions "I", the multiplication and division extension "M", the atomic instruction extension "A", the single-precision floating-point extension "F", and the double precision floating-point extension "D".

The RISC-V foundation has developed compilers, a debugger, and a number of other tools to support their Linux kernel\cite{RISCV_SS}.  Wherever possible, we intend to reuse their tools and software, as the implementation of a kernel is beyond the scope of our project.  That said, we still need to design and implement all the major components of a modern computer: A core, system busses, a device tree and peripheral drivers, a memory management unit, and a means of debugging our work.  In order to make our core useful to a Linux kernel, we will also need to implement an exception, trap, and interrupt system.  This necessitates handling both privileged and user mode instructions.

\section{Problem Constraints \& Project Viability}
In the interest of keeping our workload manageable, we have restricted ourselves to a serial processor with minimal caching.  Designing a computer is a monumental task, and we intend to start with the most basic system before committing to additional improvements.

Specifically, our base design will include the following components:
\begin{itemize}
    \item A processor core with integer and floating point pipelines to implement the RV64G ISA extensions.
    \item A control unit for the processor with control registers to implement privilege modes and traps.
    \item A MMU to support basic memory virtualization for both the core and the kernel.
    \item A serial debugger to aid kernel development and promote developer sanity.
    \item A VGA driver to display a terminal prompt.
    \item A keyboard driver to accept terminal input.
    \item A system bus to manage interaction of the core, the MMU, the kernel, and devices.
    \item A ROM unit with the bootloader code for the kernel.
    \item A DDR RAM controller for the MMU to control the onboard DDR banks.
    \item A minimal OS using BusyBox
\end{itemize}

Additional improvements discussed include caching, more sophisticated MMU, and pipelined instructions.  However, given the limited time we have to work on the project and our relative inexperience with computer design, these ideas are considered "stretch goals," to be pursued when when the base design is complete.

With respect to financial viability, our project is inexpensive by design.  Since we are implementing on an FPGA, and we intend to support common commercial, off-the-shelf peripherals, the only expenses we will incur are labor and two FPGAs for development.  

We selected the Nexys4 with DDR memory from Digilent as our platform, priced at \$320.00 each.  This platform includes USB, RS32, and micro-USB interfaces as well as a micro-SD card reader to serve as persistent storage.  The two boards are the only hardware we anticipate needing.

Our labor will vary (we will work more over the winter break), but we can estimate the number of weekly hours required to meet our goals.  While school is in session, we have 5 hours in class and an additional 5 hours outside of class each week.  For our three members, that puts us as 30 hours per week for the 16 week semester.  Over the winter break, we will be able to devote as much as 20 hours each, for a total of 60 hours in each of the 5 weeks of the winter break.  Using a local rate of \$25.00 hourly for a software engineering intern, we anticipate $(30\cdot 16 + 60\cdot 5)\cdot \$25.00 = \$19,500.00$ in labor cost.

\section{Key Milestones}
Below is a description of major components to be developed in order to achieve our base design.  These goals will likely evolve as we discover problems and continue to learn about the RISC-V ISA.  That said, here we have outlined the major pieces of our design and their individual components.  We have also included a tentative list of what parts have been delegated to what members of our team.  This too may shift if any parts become too time consuming.

\subsection{Major Components \& Descriptions}

    \subsubsection{Processor Core}
    The core processor will need to support the full RV64G extension, along with appropriate I/O to allow halting, debugging, and timing control.  The general stages include a decoder, a register file, an ALU, and a write-back shift register.
    
    \subsubsection{Floating Point Unit}
    The floating point unit will need to work in tandem with the core, as a small pipeline running in parallel to the ALU.  The control unit will need to identify FP instructions and halt the other stages of the integer pipeline until the result is ready.
    
    \subsubsection{Control Unit}
    The control unit interacts with the decoder to identify the type of instructions, and distributes control signals to the stages of the core appropriately.  It will include a state machine to manage privileged instructions and other control status register operations.
    
    \subsubsection{Memory Management Unit}
    The MMU is responsible for providing the abstraction of virtual memory, loading data from memory, and storing data to memory.  It works with the system bus and kernel to move data to and from disk when necessary.  It will also need direct access to the DDR4 RAM controller, so that it can load and store data for processes as needed.
    
    \subsubsection{System Bus}
    The system bus will handle routing of signals among the other major components in the system.  It also acts as a liason to the peripheral drivers, maintaining a mapping of addresses to peripheral registers in the style of memory-mapped IO.
    
    \subsubsection{Debugger Unit}
    The debugger maintains developer sanity as we bring up the operating system and the kernel.  The core will share the contents of its internal registers with the debugger in a read-only fashion, so that we can more effectively diagnose problems in our data and control path.

    \subsubsection{Peripherals}
    To actually use our computer as a terminal, we need a number of peripherals for human interaction.  This includes software and hardware support for at minimum a VGA monitor, a keyboard, and a removable storage (USB) drive.
    
    \subsubsection{Operating System}
    Jacob
    
    \subsubsection{Kernel}
    Jacob

    \subsubsection{Bootloaders}
    Jacob

\subsection{Component Design \& Tradeoffs}
    This section serves as a work-in-progress overview of our design and plans for individual components.  These individual components serve the needs of the major components defined above.  Note that only the parts we have designed thus far are described; the remaining components will be designed once we have a better idea of the software and hardware constraints of these major pieces.
    
    In many ways, our biggest tradeoff is development time and expertise.  This project is as much about implementing a RISC-V computer as it is about learning how the disparate parts we have studied come together.  As such, we will need to balance our ambitions with what we have the ability to learn and implement in a year's time.  To address this, we have simplified and modularized our designs such that they are relatively easy to implement and test.  This comes at the expense of overall performance.  The plan is to develop a working, simple design and iterate on it.  In this way, we can ensure a working design at the end, and implement optimizations without compromising our entire project.
    
    \subsubsection{The Core}
    Stephen
    
    \subsubsection{The Debugger}
    Cesar
    
    \subsubsection{The System Bus}
    Cesar
    
    \subsubsection{The RISC-V Kernel}
    Jacob
    
    \subsubsection{The Kernel Bootloader}
    Jacob
    
    \subsubsection{The Berkeley Bootloader}
    Jacob


\section{Tentative Task List \& Summary of Work to Date}
We have roughly divided the work among ourselves as follows.  Cesar will work on the system bus, peripheral drivers, and the debugger.  Jacob will work on the Linux kernel, the OS and its bootloader, and the software size of the debugger.  Stephen will work on the core implementation, and integration over privileged instruction with the OS.

\begin{table}[ht]
\centering
\caption{Task List}
\label{my-label}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Item}       & \textbf{Delegated To} & \textbf{Status}    & \textbf{Date Completed} \\ \hline
Decoder             & Stephen               & Complete \& tested & 11/15/17                \\ \hline
Register File       & Stephen               & Complete \& tested & 11/27/17                \\ \hline
Integer ALU         & Stephen               & WIP                & 12/20/17                \\ \hline
Atomic Unit         & Stephen               & -                  &                         \\ \hline
FP ALU              & Stephen               & Researching        &                         \\ \hline
Control Unit        & Stephen               & -                  &                         \\ \hline
Debugger            & Cesar                 & WIP                &                         \\ \hline
System Bus          & Cesar                 & -                  &                         \\ \hline
Keyboard Driver     & Cesar                 & -                  &                         \\ \hline
VGA Driver          & Cesar                 & -                  &                         \\ \hline
USB Driver          & Cesar                 & -                  &                         \\ \hline
DDR Unit            & Cesar                 & Researching        &                         \\ \hline
Minimal Kernel      & Jacob                 & WIP                &                         \\ \hline
Kernel Bootloader   & Jacob                 & Researching        &                         \\ \hline
Berkeley Bootloader & Jacob                 & -                  &                         \\ \hline
OS Built            & Jacob                 & WIP                &                         \\ \hline
MMU                 & Team                  & -                  &                         \\ \hline
\end{tabular}
\end{table}

\section{Conclusion \& Executive Summary}

\printbibliography

\end{document}
